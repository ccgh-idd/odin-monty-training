## Author: Julia Mayer
## Last modified: 26.05.2025

This is a notebook that will run our MSR model using odin2 and then fit it using monty.
For more information on the odin2 and monty packages see:
- odin2: https://mrc-ide.github.io/odin2/
- monty: https://mrc-ide.github.io/monty/
- the guidebook: https://mrc-ide.github.io/odin-monty/
- the website hosting the slides from the workshop: https://mrc-ide.github.io/odin-monty-workshop-2025/

This notebook is inspired by the mcstate vignettes.
```{r}
# Housekeeping
rm(list=ls())

# Load libraries
library(dust2)
library(odin2)
library(monty)
library(dplyr)
library(tidyr)
library(ggplot2)
```

```{r}
# Load model
# change to where your model is saved
model_path <- "/Users/juliamayer/Library/CloudStorage/OneDrive-Charité-UniversitätsmedizinBerlin/Training/To share/Model building and fitting with monty/"
model_file <- paste0(model_path, "MSR model odin 2.R")

gen_msr <- odin(model_file)
```

# Simple model run
This can be helpful to check that your model is behaving as expect (e.g., no negative numbers for people).
```{r}
# You can parse parameter values and initial states that are different from the ones specified in your odin model
pars <- list(prop = 0.9 , 
             # M1_ini = 0.5, 
             # M2_ini = 0.5,
             # R_ini = 0,
              lambda = 0.08
)

# With dt = 0.25, we take 4 steps per day. This can be changed to 0.5 or 1.
sys <- dust_system_create(gen_msr(), pars, n_particles = 20, dt = 0.25)
dust_system_set_state_initial(sys)

# This will run one iteration of the model forward over 1825 days.
time <- 0:1825
y <- dust_system_simulate(sys, time)

# Visualise how the population changes over time
# Define a palette
palette <- c("M1" = "#F2862C",  "M2" = "yellow", "S" = "#8c8cd9", "R" = "pink")

# Extract the values of the different compartments over time
M1 <- dust_unpack_state(sys, y)$M1
M2 <- dust_unpack_state(sys, y)$M2
S <- dust_unpack_state(sys, y)$S
R <- dust_unpack_state(sys, y)$R

# Plot
matplot(time, t(R), type = "l", lty = 1, col = palette[["R"]],
        xlab = "Time (days)", ylab = "Proportion of children", las = 1,
        ylim = c(0, 1.0))
matlines(time, t(M1), type = "l", lty = 1, col = palette[["M1"]])
matlines(time, t(M2), type = "l", lty = 1, col = palette[["M2"]])
matlines(time, t(S), type = "l", lty = 1, col = palette[["S"]])
legend("right", lwd = 1, col = palette, legend = names(palette), bty = "n")
```

# Fitting
If the model is behaving as expected, you can move on to the fitting.
We will fit the model to seroprevalence data using the monty package.
```{r}
# Load the data
data <- read.csv("https://raw.githubusercontent.com/Stijn-A/RSV_serology/master/data/infection_status_csv.txt", sep=",")

# Group age into intervals 
# bi-monthly for 0-2 years and 6-monthly for 2-5 years
data$age_grp <- cut(data$age_days,
                   breaks = c(seq(0,730, by = 30.25*2),
                              seq(909,2000, by = 30.25*6)), 
                   include.lowest = T, right = F)

# Get number of cases by age
seroprevalence_data <- data %>% 
  select (age_grp, age_days, infection) %>%
  mutate(N_tot = n()) %>%
  group_by(age_grp) %>%
  reframe(time = round(median(age_days)), 
            N = n(),
            n_infection = sum(infection),
            prop_seroconv = n_infection/N,
            cum_infection = prop_seroconv * N_tot) %>%
  ungroup() %>% 
  distinct()

# Calculate seroprevalence and binomial confidence intervals
seroprevalence_data[,c("seroprev_mean","seroprev_low95","seroprev_up95")] <- binom::binom.confint(seroprevalence_data$n_infection, seroprevalence_data$N, method="exact")[,c("mean","lower","upper")]

head(seroprevalence_data)
```

To fit the model, we need a function that tells us if the model output is close to the measured seroprevalence data.
This is the comparison function that is used by the particle filter and that computes the log-likelihood. When using odin2 and monty, this is done in the model (see the last three lines of my code). 
We can now build a particle filter that will use this function and test the outputs of it.
```{r}
# Build a filter and test it
filter <- dust_filter_create(gen_msr, time_start = 0, 
                             data = seroprevalence_data, 
                             n_particles = 1000)

# You can try different values for the parameters here to see how the likelihood changes
dust_likelihood_run(filter, list(prop = 0.9 #,
                                  # lambda = 0.07
                                 ),
                    save_trajectories = T) # we are saving the trajectories for plotting
```
I also find it helpful to plot the model and the data together to see why I'm getting such a value, especially if it's not what I would expect (e.g., it's very low).
```{r}
# Plot the fit
h <- dust_likelihood_last_trajectories(filter)

trajectories <- t(dust_unpack_state(filter, h)$R) # extract the proportion of seroconverted
sero_conv <- data.frame(seroprevalence_data$time, trajectories[,1])
colnames(sero_conv) <- c("time", "seroconversion")

sero_conv %>% ggplot() +
  geom_line(aes(x = time, y = seroconversion)) +
  geom_point(data = seroprevalence_data, aes(x = time, y = prop_seroconv), col = "red") +
  geom_errorbar(data = seroprevalence_data, aes(x = time, ymax = seroprev_up95, ymin = seroprev_low95), col = "red") +
  labs(x = "Age (days)", y = " Proportion seroconverted\n")
```

## The MCMC
Now we can set up our MCMC.
```{r}
# We need to define a list of inputs first
packer <- monty_packer(c("lambda", "prop"))

# Then we define the likelihood function ...
likelihood <- dust_likelihood_monty(filter, packer, save_trajectories = T)

# ... the priors
prior <- monty_dsl({
  lambda ~ Uniform (0, 0.1) # We define a FOI that has a uniform prior with limits min = 0 and max = 0.1
  prop ~ Uniform(0, 1)
  # You can add all the other parameters you want to estimate here
})

# ... and the posterior distribution
posterior <- likelihood + prior

# Finally, we need to choose our sampler. This can be a simple random walk,
# an adaptive MCMC, a Hamilton MC etc. (see vignettes). We'll take the simplest
# one (the random walk)
vcv <- diag(2) * 0.0004 # Variance-covariance matrix. This should be an YxY diagonal matrix where Y is the number of parameters you're estimating
sampler <- monty_sampler_random_walk(vcv)

# You can parallelise the process
runner <- monty_runner_callr(2, progress = T) # this should be a multiple of the number of chains you're running

# And we're ready to sample (this takes about 20 minutes on my laptop)
samples <- monty_sample(posterior, sampler, 
                        80000, # We run 80000 iterations
                        initial = c(0.01, 0.5), # These are our initial values. They should be in the same order as the parameter names in the packer above
                        n_chains = 2, # We run 2 chains
                        runner = runner)

```
We can check our results.
```{r}
# Check mixing
matplot(samples$density, type = "l", lty = 1,
        xlab = "Sample", ylab = "Log posterior probability density")
```

```{r}
# Other diagnostic tools must be imported from other packages
library(posterior)
library(bayesplot)
draws <- as_draws_df(samples)
summarise_draws(draws)
# This provides the following information:
#   - Empirical (sample) mean
#   - Empirical (sample) median
#   - Empirical (sample) standard deviation
#   - “Naive” standard error, that is the standard error of the mean (adjusting for sample size).
#   - Quantiles for each variable
#   - R hat
#   - Effective sample size
```

```{r}
# We can now also check the trace for each parameter. It should look like a hairy caterpillar
mcmc_trace(draws, facet_args = list(ncol = 1, strip.position = "left"))
```

```{r}
# We can plot posterior uncertainty intervals
draws_array <- as_draws_array(draws)
# mcmc_intervals(draws_array, pars = c("prop", "lambda")) we'll plot them separately for clarity
mcmc_intervals(draws_array, pars = "prop")
mcmc_intervals(draws_array, pars = "lambda")
```

```{r}
# And univariate marginal posterior distributions
mcmc_hist(draws_array)
```

```{r}
# As well as the trajectories that we saved earlier
trajectories <- dust_unpack_state(filter,
                                  samples$observations$trajectories)
sero_conv <- array(trajectories$R, c(19, 1000)) # 19 time steps, 1000 samples

# Plot the fit
matplot(seroprevalence_data$time, sero_conv, type = "l", col = "#00000044", lty = 1,
        xlab = "Age", ylab = "Sero-conversion")
points(x = seroprevalence_data$time, y = seroprevalence_data$prop_seroconv, pch = 19, col = "red")
arrows(x0 = seroprevalence_data$time, y0 = seroprevalence_data$seroprev_low95, 
       x1 = seroprevalence_data$time, y1 = seroprevalence_data$seroprev_up95, 
       angle = 90, code = 3, length = 0.1, col = "red")
```

This could probably be better if we tuned the results.
```{r}
# Tune the sampler
# Define a sampler (random walk)
vcv_tuned <- cov(draws[1:2]) # The variance covariance matrix is now defined by the covariance of the previous samples
sampler_tuned <- monty_sampler_random_walk(vcv_tuned)

# Sample (this takes about 30 minutes on my laptop)
samples_tuned <- monty_sample(posterior, sampler_tuned, 
                              120000, # This time we run 120,000 iterations
                              initial = c(0.01, 0.5),
                              n_chains = 2,
                              runner = runner)
```
We can check the outputs of the tuned MCMC.
```{r}
# Check mixing
matplot(samples_tuned$density, type = "l", lty = 1,
        xlab = "Sample", ylab = "Log posterior probability density")
```

```{r}
# Discard burn-in and check mixing again
samples_thinned <- monty_samples_thin(samples_tuned, burnin = 8000)

matplot(samples_thinned$density, type = "l", lty = 1,
        xlab = "Sample", ylab = "Log posterior probability density")
```

```{r}
# Check trace of for each parameter
draws_thinned <- as_draws_df(samples_thinned)
mcmc_trace(draws_thinned, facet_args = list(ncol = 1, strip.position = "left"))
```

```{r}
# Look at the summary statistics
summarise_draws(draws_thinned)
```

```{r}
draws_array_tuned <- as_draws_array(draws_thinned)
# Look at the posterior uncertainty intervals
# mcmc_intervals(draws_array_tuned, pars = c("prop", "lambda")) # again, we do this separately
mcmc_intervals(draws_array_tuned, pars = "prop")
mcmc_intervals(draws_array_tuned, pars = "lambda")
```

```{r}
# Check the univariate marginal posterior distributions
mcmc_hist(draws_array_tuned)
```

```{r}
# And plot the fit
# Trajectories
trajectories <- dust_unpack_state(filter,
                                  samples_thinned$observations$trajectories)
sero_conv <- array(trajectories$R, c(19, 1000))

matplot(seroprevalence_data$time, sero_conv, type = "l", col = "#00000044", lty = 1,
        xlab = "Age", ylab = "Sero-conversion", main = "Model fit")
points(x = seroprevalence_data$time, y = seroprevalence_data$prop_seroconv, pch = 19, col = "red")
arrows(x0 = seroprevalence_data$time, y0 = seroprevalence_data$seroprev_low95, 
       x1 = seroprevalence_data$time, y1 = seroprevalence_data$seroprev_up95, 
       angle = 90, code = 3, length = 0.1, col = "red")
```